using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

// Main class for handling player movement
public class PlayerMovement : MonoBehaviour
{
    public float moveSpeed = 5f; // Base speed
    public float sprintMultiplier = 2f; // Multiplier for sprinting speed
    public Rigidbody2D rb; // 2D physics body reference used for movement and collision
    public Animator animator; // Animator reference for controlling animations

    private Vector2 startPosition; // Initial player position
    private Vector2 lastMovement; // Tracks that last direction the player moved in
    private PlayerControls controls; // Instance of PlayerControls class generated by Input System
    private Vector2 targetPosition; // Target position the player should move to
    private bool isMoving = false; // A flag to check if player is currently moving
    private bool isTurning = false; // A flag to check is player is currently turning
    private Vector2 currentInput; // Current movement input
    private bool isSprinting = false; // A flag to check if sprinting

    // Called when script is loaded
    void Awake()
    {
        controls = new PlayerControls(); // Initialized controls object, handles player input
        controls.Player.Move.performed += ctx => OnMoveInput(ctx.ReadValue<Vector2>()); // Event triggered when move input is detected
        controls.Player.Move.canceled += ctx => OnMoveCanceled(); // Event triggered when move input is cancelled
        controls.Player.Sprint.performed += ctx => OnSprintStart(); // Listen for Shift key press
        controls.Player.Sprint.canceled += ctx => OnSprintEnd(); // Listen for Shift key release
    }

    // Called when object is enabled/active - enabled control system
    private void OnEnable()
    {
        controls.Enable();
    }

    // Called when object is disabled/inactive - disables control system
    private void OnDisable()
    {
        controls.Disable();
    }

    // Called before first frame update - initializes player start position, sets target to start position
    void Start()
    {
        startPosition = new Vector2(0.5f, 0f);
        rb.position = startPosition;
        targetPosition = rb.position;
    }

    // Handles movement input
    private void OnMoveInput(Vector2 input)
    {
        // Adjusts input to snap to cardinal directions
        Vector2 roundedInput = Vector2.zero;
        if (Mathf.Abs(input.x) > Mathf.Abs(input.y))
        {
            roundedInput.x = Mathf.Sign(input.x);
        }
        else if (input.y != 0)
        {
            roundedInput.y = Mathf.Sign(input.y);
        }

        currentInput = roundedInput;
        Debug.Log($"OnMoveInput - Input: {input}, Rounded: {roundedInput}");

        if (roundedInput != Vector2.zero && !isTurning)
        {
            if (roundedInput != lastMovement)
            {
                SnapToGrid();
                StopMovement(); // Ensure Minji stops before turning
                StartTurn(roundedInput);
            }
            else if (!isMoving)
            {
                StartMove(roundedInput);
            }
        }
    }

    // Called when move input is canceled/player stops pressing direction key
    private void OnMoveCanceled()
    {
        currentInput = Vector2.zero;
        Debug.Log("Move input canceled");
        if (isMoving)
        {
            targetPosition = GetNextWholePosition(rb.position, lastMovement);
            Debug.Log($"OnMoveCanceled - New target: {targetPosition}");
        }
    }

    // Sprints when Shift is pressed
    private void OnSprintStart()
    {
        isSprinting = true;
        Debug.Log("Sprint started");
    }

    // Stops sprinting when Shift is not pressed
    private void OnSprintEnd()
    {
        isSprinting = false;
        Debug.Log("Sprint ended");
    }

    // Snaps player to nearest grid position before changing direction
    private void SnapToGrid()
    {
        Vector2 oldPosition = rb.position;
        rb.position = new Vector2(
            Mathf.Round(rb.position.x - startPosition.x) + startPosition.x,
            Mathf.Round(rb.position.y - startPosition.y) + startPosition.y
        );
        targetPosition = rb.position;
        Debug.Log($"SnapToGrid - Old: {oldPosition}, New: {rb.position}");
    }

    // Handles turning player to face new direction
    private void StartTurn(Vector2 inputDirection)
    {
        isTurning = true;
        lastMovement = inputDirection;
        animator.SetFloat("Speed", 0);
        UpdateAnimatorParameters(inputDirection);
        Debug.Log($"StartTurn - Direction: {inputDirection}");

        StartCoroutine(WaitForTurnToComplete());
    }

    // Makes player pause for a moment to les turning complete
    private IEnumerator WaitForTurnToComplete()
    {
        yield return new WaitForSeconds(0.1f); // Adjust this delay to match the turn animation length
        isTurning = false;
        Debug.Log("Turn completed");

        if (currentInput != Vector2.zero)
        {
            StartMove(lastMovement); // Move after the turn is complete
        }
    }

    // Starts moving player to target position
    private void StartMove(Vector2 inputDirection)
    {
        targetPosition = GetNextWholePosition(rb.position, inputDirection);
        isMoving = true;
        animator.SetFloat("Speed", 1);
        UpdateAnimatorParameters(inputDirection);
        Debug.Log($"StartMove - Direction: {inputDirection}, Target: {targetPosition}");
    }

    // Stops the player moving and stops walk animation
    private void StopMovement()
    {
        isMoving = false;
        animator.SetFloat("Speed", 0);
        Debug.Log("StopMovement - Movement stopped");
    }

    // Updates animator parameters based on player's current direction
    private void UpdateAnimatorParameters(Vector2 direction)
    {
        animator.SetFloat("LastHorizontal", direction.x);
        animator.SetFloat("LastVertical", direction.y);
    }

    // Called at fixed intervals (usually for physics calculations)
    void FixedUpdate()
    {
        if (isMoving)
        {
            // Calculate the movement speed (doubled if sprinting)
            float currentMoveSpeed = isSprinting ? moveSpeed * sprintMultiplier : moveSpeed;

            Vector2 oldPosition = rb.position;
            rb.MovePosition(Vector2.MoveTowards(rb.position, targetPosition, currentMoveSpeed * Time.fixedDeltaTime));
            Debug.Log($"FixedUpdate - Old: {oldPosition}, New: {rb.position}, Target: {targetPosition}, Speed: {currentMoveSpeed}");

            if (Vector2.Distance(rb.position, targetPosition) < 0.01f)
            {
                rb.position = targetPosition;
                Debug.Log($"Reached target - Position: {rb.position}");

                if (currentInput != Vector2.zero)
                {
                    if (currentInput != lastMovement)
                    {
                        lastMovement = currentInput;
                        Debug.Log($"Changing direction - New: {lastMovement}");
                    }
                    StartMove(currentInput);
                }
                else
                {
                    isMoving = false;
                    animator.SetFloat("Speed", 0);
                    Debug.Log("Stopped moving");
                }
            }
        }
    }

    // Calculates the next grid-aligned position based on player's current position and direction
    private Vector2 GetNextWholePosition(Vector2 currentPosition, Vector2 direction)
    {
        Vector2 nextPosition = currentPosition + direction;
        Vector2 result = new Vector2(
            Mathf.Round(nextPosition.x - startPosition.x) + startPosition.x,
            Mathf.Round(nextPosition.y - startPosition.y) + startPosition.y
        );
        Debug.Log($"GetNextWholePosition - Current: {currentPosition}, Direction: {direction}, Result: {result}");
        return result;
    }

    // Logs collision events
    void OnCollisionEnter2D(Collision2D collision)
    {
        Debug.Log($"Collided with: {collision.gameObject.name} at position {rb.position}");
    }
}
